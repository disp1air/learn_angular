Dependency Injection - позволяет не создавать зависимости (экземпляры сервисов), а запрашивать их (использовать уже готовые).  

Change detection - механизм который позволяет обнаруживать изменения, обновлять представления.  

Роутер может загружать модули (modules lazy loading) - это позволяет при старте приложения сделать небольшрй бандл, а затем уже подгружать все остальное по мере необходимости.  

Когда мы создаем новый компонент, то мы создаем новые теги для html и обучаете эти теги как они должны себя вести и что отображать.  
Директивы - они состоят из двух частей(класс и метаинформация) и отличаются от компонентов тем что у директив нет шаблона - это новые аттрибуты которые добавляются к тегам в html и за этими аттрибутами стоит определенный код, который выполняет определенную работу.  

Т.е. компонент это тег, а директива - аттрибут  

Property binding, event binding ???  

Передача информации из свойств класса происходит в проперти DOM-объекта, т.е. не в аттрибуты. Передача информации из шаблона в класс компонента происходит с помощью event binding  

Сервис это класс который предоставляет определенную бизнес-логику, данные и может использоваться компонентами, директивами, другими сервисами  

Модульная система Angular  

@NgModule({})

Область действия компонентов, директив, пайпов - это модуль. Не может быть такого, чтобы они были сами по себе. Они всегда принадлежат модулю и всегда принадлежат только одному.  

[declarations] - объявляет какие компоненты, директивы, пайпы относятся к текущему модулю  
[providers] - указываются классы сервисов(один из вариантов регистрации сервисов)

[imports] - указываются модули которые нужны для реализации текущего модуля. Все что эти модули экспортируют мы можем использовать  
[exports] - какие компоненты, директивы, пайпы мы хотим сделать публичными. Также могут присутствовать другие модули.    

Что же означает доступность в рамках модуля - это значит что любой компонент, директива, пайп используется в шаблоне любого другого компонента который в этом модуле находится  

[entryComponents] - классы динамически-загружаемых компонентов  

[bootstrap] - опция только в рутовом модуле и указывает какой компонент является руторым. Именно он используется для старта приложения.  

[schema] - NO_ERRORS-SCHEMA, CUSTOM_ELEMENTS_SCHEMA  

Файл main.ts является стартовой точкой приложения  

COMPONENT  
Компонент это сущность у которой есть внешний вид.  
Компонент состоит из трех частей - класс, метадата и шаблон. 
Жизненный цикл состоит из ряда точек в которые мы можем запускать определенную бизнес-логику  
Публичные свойства доступны в шаблоне данного компонента. Приватные свойства не нужно использовать в шаблоне  
Роль конструкторов - внедрение зависимостей - DI  
ngOnInit - инициализация компонента  
если метод является обработчиком на какое-то действие в шаблоне(например click) то его название должно начинаться с on...  

Структурные директивы(которые со *) - ngFor - позволяет создать нам несколько сущностей, таких же сущностей для которых применяется эта директива (т.е. если мы хотим несколько элементов li то должны применить ngFor для одного li елемента). Структурные директивы влияют на DOM  

ngFor properties: index, odd, even, first, last  

<!-- <li *ngFor="let task of tasks; let i = index; let o = odd;">   -->

{{}} - интерполяция(один из видов property-binding-а)  

Стандартные html теги не содержат дефис.  

[task]="selectedTask" - property binding  

DIRECTIVE
директива влияет на компонент к которому она применяется или влияет на какой-то html элемент к которому она применяется как атрибут  
Селектор у директив - CSS селектор по атрибуту  

data binding  
                                <-------------interpolation: {{task.action}}----------   
    DOM
                                <-----Property binding: \[task]="selectedTask"--------      Component
 Component
(Template)                      ----Event binding: (click)="onSelectTask(task)"------>       (Class)

                                <-------Two way binding: [(ngModel)]="task.action"--->  

SERVICES  
Любой класс можно использовать как сервис - единственное что нужно это создать класс и зарегистрировать  
Если региструруется сервис в модуле то декоратор(Injectable не нужен, но он не нужен до тех пор пока в сервисе не появляется конструктор. если у сервиса появляется конструктор то значит у сервиса есть свои зависимости то тогда Injectable нужен- поэтому лучше ставить его всегда)  

DI  
constructor(private taskService: TaskService) {} - происходит то что создается у этого класса приватное свойство которое по имени совпадает с именем параметра(taskService) и оно инициализируется экземпляром класса TaskService - т.е. не нужно отдельно заводить своиство и не нужно его отдельно инициализировать. Главное добавить модификатор доступа к параметру - если его не будет то ничего не будет происходить.  

tsconfig - файл где конфигурируется typescript компилятор  
angular.json - конфигурация проекта  
    sourceRoot - где находится код  
    outputPath - куда будут складываться то что мы скомпилируем  
    index - где находится index.html  
    main - где main.ts  


В app.module подключаем browsermodule, а в остальных модулях - commonModule (для отображения структурных директив)
Область действия сервисов - не модуль а все приложение  

В качестве источника данных для выражений в раметке - обычно экземпляр класса, компонента(его публичные свойства). Кроме экземпляра класса могут использоваться:  
переменные которые создаем в ngFor (template input variable - доступны только в рамках ngFor), шаблонные переменные(template reference variable - доступны во всем шаблоне)  

В шаблоне нельзя получить доступ к глобальному пространству(т.е. нельзя использовать window, document, console, но можно undefined)  

COMMUNICATION BETWEEN COMPONENTS  
1 - когда требуется коммуницировать родительскому и дочернему компонентам(input/output)
2 - использование сервисов  
3 - используя шаблонную переменную  

Если у родительского компонента есть данные которые он не хочет отображать а хочет делегировать их отображение дочернему элементу - то у дочернего элемента должен быть input в который родительский элемент и передаст данные для отображения  

Чтобы указать что у компонента есть input - используется декоратор @Input перед свойством  

export class InputExampleComponent {
    @Input() name: string;  
    @Input('old.Age') age: number; 
}

</\input-example [name]="myName" [old.Age]="myAge"> 
</\/input-example>

EVENTS  
1 - DOM events  
2 - Custom events (события которые передает дочерний компонент родительскому)  

Чтобы получить больше информации о событии используется $event - используется как в DOM так и в custom  
 
